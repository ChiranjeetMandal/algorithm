<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="cj">
        <link rel="canonical" href="https://cjql.github.io/algorithm/Chap22/22.3/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>22.3 Depth-first search - 算法</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../../css/katex.css" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" rel="stylesheet">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-117404761-1', 'auto');
            ga('send', 'pageview');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">算法</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">基 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">1 算法在计算机中的作用</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap01/1.1/" class="dropdown-item">1.1 Algorithms</a>
</li>
            
<li>
    <a href="../../Chap01/1.2/" class="dropdown-item">1.2 Algorithms as a technology</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 1 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap01/Problems/1-1/" class="dropdown-item">Problem 1-1</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2 Getting Started</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap02/2.1/" class="dropdown-item">2.1 Insertion sort</a>
</li>
            
<li>
    <a href="../../Chap02/2.2/" class="dropdown-item">2.2 Analyzing algorithms</a>
</li>
            
<li>
    <a href="../../Chap02/2.3/" class="dropdown-item">2.3 Designing algorithms</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 2 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap02/Problems/2-1/" class="dropdown-item">2-1 Insertion sort on small arrays in merge sort</a>
</li>
            
<li>
    <a href="../../Chap02/Problems/2-2/" class="dropdown-item">2-2 Correctness of bubblesort</a>
</li>
            
<li>
    <a href="../../Chap02/Problems/2-3/" class="dropdown-item">2-3 Correctness of Horner's rule</a>
</li>
            
<li>
    <a href="../../Chap02/Problems/2-4/" class="dropdown-item">2-4 Inversions</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">3 Growth of Functions</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap03/3.1/" class="dropdown-item">3.1 Asymptotic notation</a>
</li>
            
<li>
    <a href="../../Chap03/3.2/" class="dropdown-item">3.2 Standard notations and common functions</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 3 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap03/Problems/3-1/" class="dropdown-item">3-1 Asymptotic behavior of polynomials</a>
</li>
            
<li>
    <a href="../../Chap03/Problems/3-2/" class="dropdown-item">3-2 Relative asymptotic growths</a>
</li>
            
<li>
    <a href="../../Chap03/Problems/3-3/" class="dropdown-item">3-3 Ordering by asymptotic growth rates</a>
</li>
            
<li>
    <a href="../../Chap03/Problems/3-4/" class="dropdown-item">3-4 Asymptotic notation properties</a>
</li>
            
<li>
    <a href="../../Chap03/Problems/3-5/" class="dropdown-item">3-5 Variations on $O$ and $\Omega$</a>
</li>
            
<li>
    <a href="../../Chap03/Problems/3-6/" class="dropdown-item">3-6 Iterated functions</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">4 Divide-and-Conquer</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap04/4.1/" class="dropdown-item">4.1 The maximum-subarray problem</a>
</li>
            
<li>
    <a href="../../Chap04/4.2/" class="dropdown-item">4.2 Strassen's algorithm for matrix multiplication</a>
</li>
            
<li>
    <a href="../../Chap04/4.3/" class="dropdown-item">4.3 The substitution method for solving recurrences</a>
</li>
            
<li>
    <a href="../../Chap04/4.4/" class="dropdown-item">4.4 The recursion-tree method for solving recurrences</a>
</li>
            
<li>
    <a href="../../Chap04/4.5/" class="dropdown-item">4.5 The master method for solving recurrences</a>
</li>
            
<li>
    <a href="../../Chap04/4.6/" class="dropdown-item">4.6 Proof of the master theorem</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 4 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap04/Problems/4-1/" class="dropdown-item">4-1 Recurrence examples</a>
</li>
            
<li>
    <a href="../../Chap04/Problems/4-2/" class="dropdown-item">4-2 Parameter-passing costs</a>
</li>
            
<li>
    <a href="../../Chap04/Problems/4-3/" class="dropdown-item">4-3 More recurrence examples</a>
</li>
            
<li>
    <a href="../../Chap04/Problems/4-4/" class="dropdown-item">4-4 Fibonacci numbers</a>
</li>
            
<li>
    <a href="../../Chap04/Problems/4-5/" class="dropdown-item">4-5 Chip testing</a>
</li>
            
<li>
    <a href="../../Chap04/Problems/4-6/" class="dropdown-item">4-6 Monge arrays</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">5 Probabilistic Analysis and Randomized Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap05/5.1/" class="dropdown-item">5.1 The hiring problem</a>
</li>
            
<li>
    <a href="../../Chap05/5.2/" class="dropdown-item">5.2 Indicator random variables</a>
</li>
            
<li>
    <a href="../../Chap05/5.3/" class="dropdown-item">5.3 Randomized algorithms</a>
</li>
            
<li>
    <a href="../../Chap05/5.4/" class="dropdown-item">5.4 Probabilistic analysis and further uses of indicator random variables</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 5 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap05/Problems/5-1/" class="dropdown-item">5-1 Probabilstic counting</a>
</li>
            
<li>
    <a href="../../Chap05/Problems/5-2/" class="dropdown-item">5-2 Searching an unsorted array</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">序 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">6 Heapsort</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap06/6.1/" class="dropdown-item">6.1 Heaps</a>
</li>
            
<li>
    <a href="../../Chap06/6.2/" class="dropdown-item">6.2 Maintaining the heap property</a>
</li>
            
<li>
    <a href="../../Chap06/6.3/" class="dropdown-item">6.3 Building a heap</a>
</li>
            
<li>
    <a href="../../Chap06/6.4/" class="dropdown-item">6.4 The heapsort algorithm</a>
</li>
            
<li>
    <a href="../../Chap06/6.5/" class="dropdown-item">6.5 Priority queues</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 6 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap06/Problems/6-1/" class="dropdown-item">6-1 Building a heap using insertion</a>
</li>
            
<li>
    <a href="../../Chap06/Problems/6-2/" class="dropdown-item">6-2 Analysis of $d$-ary heaps</a>
</li>
            
<li>
    <a href="../../Chap06/Problems/6-3/" class="dropdown-item">6-3 Young tableaus</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">7 Quicksort</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap07/7.1/" class="dropdown-item">7.1 Description of quicksort</a>
</li>
            
<li>
    <a href="../../Chap07/7.2/" class="dropdown-item">7.2 Performance of quicksort</a>
</li>
            
<li>
    <a href="../../Chap07/7.3/" class="dropdown-item">7.3 A randomized version of quicksort</a>
</li>
            
<li>
    <a href="../../Chap07/7.4/" class="dropdown-item">7.4 Analysis of quicksort</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 7 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap07/Problems/7-1/" class="dropdown-item">7-1 Hoare partition correctness</a>
</li>
            
<li>
    <a href="../../Chap07/Problems/7-2/" class="dropdown-item">7-2 Quicksort with equal element values</a>
</li>
            
<li>
    <a href="../../Chap07/Problems/7-3/" class="dropdown-item">7-3 Alternative quicksort analysis</a>
</li>
            
<li>
    <a href="../../Chap07/Problems/7-4/" class="dropdown-item">7-4 Stack depth for quicksort</a>
</li>
            
<li>
    <a href="../../Chap07/Problems/7-5/" class="dropdown-item">7-5 Median-of-3 partition</a>
</li>
            
<li>
    <a href="../../Chap07/Problems/7-6/" class="dropdown-item">7-6 Fuzzy sorting of intervals</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">8 Sorting in Linear Time</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap08/8.1/" class="dropdown-item">8.1 Lower bounds for sorting</a>
</li>
            
<li>
    <a href="../../Chap08/8.2/" class="dropdown-item">8.2 Counting sort</a>
</li>
            
<li>
    <a href="../../Chap08/8.3/" class="dropdown-item">8.3 Radix sort</a>
</li>
            
<li>
    <a href="../../Chap08/8.4/" class="dropdown-item">8.4 Bucket sort</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 8 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap08/Problems/8-1/" class="dropdown-item">8-1 Probabilistic lower bounds on comparison sorting</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-2/" class="dropdown-item">8-2 Sorting in place in linear time</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-3/" class="dropdown-item">8-3 Sorting variable-length items</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-4/" class="dropdown-item">8-4 Water jugs</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-5/" class="dropdown-item">8-5 Average sorting</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-6/" class="dropdown-item">8-6 Lower bound on merging sorted lists</a>
</li>
            
<li>
    <a href="../../Chap08/Problems/8-7/" class="dropdown-item">8-7 The $0$-$1$ sorting lemma and columnsort</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">9 Medians and Order Statistics</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap09/9.1/" class="dropdown-item">9.1 Minimum and maximum</a>
</li>
            
<li>
    <a href="../../Chap09/9.2/" class="dropdown-item">9.2 Selection in expected linear time</a>
</li>
            
<li>
    <a href="../../Chap09/9.3/" class="dropdown-item">9.3 Selection in worst-case linear time</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 9 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap09/Problems/9-1/" class="dropdown-item">9-1 Largest $i$ numbers in sorted order</a>
</li>
            
<li>
    <a href="../../Chap09/Problems/9-2/" class="dropdown-item">9-2 Weighted median</a>
</li>
            
<li>
    <a href="../../Chap09/Problems/9-3/" class="dropdown-item">9-3 Small order statistics</a>
</li>
            
<li>
    <a href="../../Chap09/Problems/9-4/" class="dropdown-item">9-4 Alternative analysis of randomized selection</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">数构 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">10 Elementary Data Structures</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap10/10.1/" class="dropdown-item">10.1 Stacks and queues</a>
</li>
            
<li>
    <a href="../../Chap10/10.2/" class="dropdown-item">10.2 Linked lists</a>
</li>
            
<li>
    <a href="../../Chap10/10.3/" class="dropdown-item">10.3 Implementing pointers and objects</a>
</li>
            
<li>
    <a href="../../Chap10/10.4/" class="dropdown-item">10.4 Representing rooted trees</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 10 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap10/Problems/10-1/" class="dropdown-item">10-1 Comparisons among lists</a>
</li>
            
<li>
    <a href="../../Chap10/Problems/10-2/" class="dropdown-item">10-2 Mergeable heaps using linked lists</a>
</li>
            
<li>
    <a href="../../Chap10/Problems/10-3/" class="dropdown-item">10-3 Searching a sorted compact list</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">11 Hash Tables</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap11/11.1/" class="dropdown-item">11.1 Direct-address tables</a>
</li>
            
<li>
    <a href="../../Chap11/11.2/" class="dropdown-item">11.2 Hash tables</a>
</li>
            
<li>
    <a href="../../Chap11/11.3/" class="dropdown-item">11.3 Hash functions</a>
</li>
            
<li>
    <a href="../../Chap11/11.4/" class="dropdown-item">11.4 Open addressing</a>
</li>
            
<li>
    <a href="../../Chap11/11.5/" class="dropdown-item">11.5 Perfect hashing</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 11 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap11/Problems/11-1/" class="dropdown-item">11-1 Longest-probe bound for hashing</a>
</li>
            
<li>
    <a href="../../Chap11/Problems/11-2/" class="dropdown-item">11-2 Slot-size bound for chaining</a>
</li>
            
<li>
    <a href="../../Chap11/Problems/11-3/" class="dropdown-item">11-3 Quadratic probing</a>
</li>
            
<li>
    <a href="../../Chap11/Problems/11-4/" class="dropdown-item">11-4 Hashing and authentication</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">12 Binary Search Trees</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap12/12.1/" class="dropdown-item">12.1 What is a binary search tree?</a>
</li>
            
<li>
    <a href="../../Chap12/12.2/" class="dropdown-item">12.2 Querying a binary search tree</a>
</li>
            
<li>
    <a href="../../Chap12/12.3/" class="dropdown-item">12.3 Insertion and deletion</a>
</li>
            
<li>
    <a href="../../Chap12/12.4/" class="dropdown-item">12.4 Randomly built binary search trees</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 12 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap12/Problems/12-1/" class="dropdown-item">12-1 Binary search trees with equal keys</a>
</li>
            
<li>
    <a href="../../Chap12/Problems/12-2/" class="dropdown-item">12-2 Radix trees</a>
</li>
            
<li>
    <a href="../../Chap12/Problems/12-3/" class="dropdown-item">12-3 Average node depth in a randomly built binary search tree</a>
</li>
            
<li>
    <a href="../../Chap12/Problems/12-4/" class="dropdown-item">12-4 Number of different binary trees</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">13 Red-Black Trees</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap13/13.1/" class="dropdown-item">13.1 Properties of red-black trees</a>
</li>
            
<li>
    <a href="../../Chap13/13.2/" class="dropdown-item">13.2 Rotations</a>
</li>
            
<li>
    <a href="../../Chap13/13.3/" class="dropdown-item">13.3 Insertion</a>
</li>
            
<li>
    <a href="../../Chap13/13.4/" class="dropdown-item">13.4 Deletion</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 13 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap13/Problems/13-1/" class="dropdown-item">13-1 Persistent dynamic sets</a>
</li>
            
<li>
    <a href="../../Chap13/Problems/13-2/" class="dropdown-item">13-2 Join operation on red-black trees</a>
</li>
            
<li>
    <a href="../../Chap13/Problems/13-3/" class="dropdown-item">13-3 AVL trees</a>
</li>
            
<li>
    <a href="../../Chap13/Problems/13-4/" class="dropdown-item">13-4 Treaps</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">14 Augmenting Data Structures</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap14/14.1/" class="dropdown-item">14.1 Dynamic order statistics</a>
</li>
            
<li>
    <a href="../../Chap14/14.2/" class="dropdown-item">14.2 How to augment a data structure</a>
</li>
            
<li>
    <a href="../../Chap14/14.3/" class="dropdown-item">14.3 Interval trees</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 14 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap14/Problems/14-1/" class="dropdown-item">14-1 Point of maximum overlap</a>
</li>
            
<li>
    <a href="../../Chap14/Problems/14-2/" class="dropdown-item">14-2 Josephus permutation</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">高级 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">15 Dynamic Programming</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap15/15.1/" class="dropdown-item">15.1 Rod cutting</a>
</li>
            
<li>
    <a href="../../Chap15/15.2/" class="dropdown-item">15.2 Matrix-chain multiplication</a>
</li>
            
<li>
    <a href="../../Chap15/15.3/" class="dropdown-item">15.3 Elements of dynamic programming</a>
</li>
            
<li>
    <a href="../../Chap15/15.4/" class="dropdown-item">15.4 Longest common subsequence</a>
</li>
            
<li>
    <a href="../../Chap15/15.5/" class="dropdown-item">15.5 Optimal binary search trees</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 15 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap15/Problems/15-1/" class="dropdown-item">15-1 Longest simple path in a directed acyclic graph</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-2/" class="dropdown-item">15-2 Longest palindrome subsequence</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-3/" class="dropdown-item">15-3 Bitonic euclidean</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-4/" class="dropdown-item">15-4 Printing neatly</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-5/" class="dropdown-item">15-5 Edit distance</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-6/" class="dropdown-item">15-6 Planning a company party</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-7/" class="dropdown-item">15-7 Viterbi algorithm</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-8/" class="dropdown-item">15-8 Image compression by seam carving</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-9/" class="dropdown-item">15-9 Breaking a string</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-10/" class="dropdown-item">15-10 Planning an investment strategy</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-11/" class="dropdown-item">15-11 Inventory planning</a>
</li>
            
<li>
    <a href="../../Chap15/Problems/15-12/" class="dropdown-item">15-12 Signing free-agent baseball players</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">16 Greedy Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap16/16.1/" class="dropdown-item">16.1 An activity-selection problem</a>
</li>
            
<li>
    <a href="../../Chap16/16.2/" class="dropdown-item">16.2 Elements of the greedy strategy</a>
</li>
            
<li>
    <a href="../../Chap16/16.3/" class="dropdown-item">16.3 Huffman codes</a>
</li>
            
<li>
    <a href="../../Chap16/16.4/" class="dropdown-item">16.4 Matroids and greedy methods</a>
</li>
            
<li>
    <a href="../../Chap16/16.5/" class="dropdown-item">16.5 A task-scheduling problem as a matroid</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 16 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap16/Problems/16-1/" class="dropdown-item">16-1 Coin changing</a>
</li>
            
<li>
    <a href="../../Chap16/Problems/16-2/" class="dropdown-item">16-2 Scheduling to minimize average completion time</a>
</li>
            
<li>
    <a href="../../Chap16/Problems/16-3/" class="dropdown-item">16-3 Acyclic subgraphs</a>
</li>
            
<li>
    <a href="../../Chap16/Problems/16-4/" class="dropdown-item">16-4 Scheduling variations</a>
</li>
            
<li>
    <a href="../../Chap16/Problems/16-5/" class="dropdown-item">16-5 Off-line caching</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">17 Amortized Analysis</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap17/17.1/" class="dropdown-item">17.1 Aggregate analysis</a>
</li>
            
<li>
    <a href="../../Chap17/17.2/" class="dropdown-item">17.2 The accounting method</a>
</li>
            
<li>
    <a href="../../Chap17/17.3/" class="dropdown-item">17.3 The potential method</a>
</li>
            
<li>
    <a href="../../Chap17/17.4/" class="dropdown-item">17.4 Dynamic tables</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 17 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap17/Problems/17-1/" class="dropdown-item">17-1 Bit-reversed binary counter</a>
</li>
            
<li>
    <a href="../../Chap17/Problems/17-2/" class="dropdown-item">17-2 Making binary search dynamic</a>
</li>
            
<li>
    <a href="../../Chap17/Problems/17-3/" class="dropdown-item">17-3 Amortized weight-balanced trees</a>
</li>
            
<li>
    <a href="../../Chap17/Problems/17-4/" class="dropdown-item">17-4 The cost of restructuring red-black trees</a>
</li>
            
<li>
    <a href="../../Chap17/Problems/17-5/" class="dropdown-item">17-5 Competitive analysis of self-organizing lists with move-to-front</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">高构 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">18 B-Trees</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap18/18.1/" class="dropdown-item">18.1 Definition of B-trees</a>
</li>
            
<li>
    <a href="../../Chap18/18.2/" class="dropdown-item">18.2 Basic operations on B-trees</a>
</li>
            
<li>
    <a href="../../Chap18/18.3/" class="dropdown-item">18.3 Deleting a key from a B-tree</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 18 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap18/Problems/18-1/" class="dropdown-item">18-1 Stacks on secondary storage</a>
</li>
            
<li>
    <a href="../../Chap18/Problems/18-2/" class="dropdown-item">18-2 Joining and splitting 2-3-4 trees</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">19 Fibonacci Heaps</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap19/19.1/" class="dropdown-item">19.1 Structure of Fibonacci heaps</a>
</li>
            
<li>
    <a href="../../Chap19/19.2/" class="dropdown-item">19.2 Mergeable-heap operations</a>
</li>
            
<li>
    <a href="../../Chap19/19.3/" class="dropdown-item">19.3 Decreasing a key and deleting a node</a>
</li>
            
<li>
    <a href="../../Chap19/19.4/" class="dropdown-item">19.4 Bounding the maximum degree</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 19 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap19/Problems/19-1/" class="dropdown-item">19-1 Alternative implementation of deletion</a>
</li>
            
<li>
    <a href="../../Chap19/Problems/19-2/" class="dropdown-item">19-2 Binomial trees and binomial heaps</a>
</li>
            
<li>
    <a href="../../Chap19/Problems/19-3/" class="dropdown-item">19-3 More Fibonacci-heap operations</a>
</li>
            
<li>
    <a href="../../Chap19/Problems/19-4/" class="dropdown-item">19-4 2-3-4 heaps</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">20 van Emde Boas Trees</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap20/20.1/" class="dropdown-item">20.1 Preliminary approaches</a>
</li>
            
<li>
    <a href="../../Chap20/20.2/" class="dropdown-item">20.2 A recursive structure</a>
</li>
            
<li>
    <a href="../../Chap20/20.3/" class="dropdown-item">20.3 The van Emde Boas tree</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 20 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap20/Problems/20-1/" class="dropdown-item">20-1 Space requirements for van Emde Boas trees</a>
</li>
            
<li>
    <a href="../../Chap20/Problems/20-2/" class="dropdown-item">20-2 $y$-fast tries</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">21 Data Structures for Disjoint Sets</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap21/21.1/" class="dropdown-item">21.1 Disjoint-set operations</a>
</li>
            
<li>
    <a href="../../Chap21/21.2/" class="dropdown-item">21.2 Linked-list representation of disjoint sets</a>
</li>
            
<li>
    <a href="../../Chap21/21.3/" class="dropdown-item">21.3 Disjoint-set forests</a>
</li>
            
<li>
    <a href="../../Chap21/21.4/" class="dropdown-item">21.4 Analysis of union by rank with path compression</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 21 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap21/Problems/21-1/" class="dropdown-item">21-1 Off-line minimum</a>
</li>
            
<li>
    <a href="../../Chap21/Problems/21-2/" class="dropdown-item">21-2 Depth determination</a>
</li>
            
<li>
    <a href="../../Chap21/Problems/21-3/" class="dropdown-item">21-3 Tarjan's off-line least-common-ancestors algorithm</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">图 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">22 Elementary Graph Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../22.1/" class="dropdown-item">22.1 Representations of graphs</a>
</li>
            
<li>
    <a href="../22.2/" class="dropdown-item">22.2 Breadth-first search</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">22.3 Depth-first search</a>
</li>
            
<li>
    <a href="../22.4/" class="dropdown-item">22.4 Topological sort</a>
</li>
            
<li>
    <a href="../22.5/" class="dropdown-item">22.5 Strongly connected components</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 22 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../Problems/22-1/" class="dropdown-item">22-1 Classifying edges by breadth-first search</a>
</li>
            
<li>
    <a href="../Problems/22-2/" class="dropdown-item">22-2 Articulation points, bridges, and biconnected components</a>
</li>
            
<li>
    <a href="../Problems/22-3/" class="dropdown-item">22-3 Euler tour</a>
</li>
            
<li>
    <a href="../Problems/22-4/" class="dropdown-item">22-4 Reachability</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">23 Minimum Spanning Trees</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap23/23.1/" class="dropdown-item">23.1 Growing a minimum spanning tree</a>
</li>
            
<li>
    <a href="../../Chap23/23.2/" class="dropdown-item">23.2 The algorithms of Kruskal and Prim</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 23 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap23/Problems/23-1/" class="dropdown-item">23-1 Second-best minimum spanning tree</a>
</li>
            
<li>
    <a href="../../Chap23/Problems/23-2/" class="dropdown-item">23-2 Minimum spanning tree in sparse graphs</a>
</li>
            
<li>
    <a href="../../Chap23/Problems/23-3/" class="dropdown-item">23-3 Bottleneck spanning tree</a>
</li>
            
<li>
    <a href="../../Chap23/Problems/23-4/" class="dropdown-item">23-4 Alternative minimum-spanning-tree algorithms</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">24 Single-Source Shortest Paths</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap24/24.1/" class="dropdown-item">24.1 The Bellman-Ford algorithm</a>
</li>
            
<li>
    <a href="../../Chap24/24.2/" class="dropdown-item">24.2 Single-source shortest paths in directed acyclic graphs</a>
</li>
            
<li>
    <a href="../../Chap24/24.3/" class="dropdown-item">24.3 Dijkstra's algorithm</a>
</li>
            
<li>
    <a href="../../Chap24/24.4/" class="dropdown-item">24.4 Difference constraints and shortest paths</a>
</li>
            
<li>
    <a href="../../Chap24/24.5/" class="dropdown-item">24.5 Proofs of shortest-paths properties</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 24 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap24/Problems/24-1/" class="dropdown-item">24-1 Yen's improvement to Bellman-Ford</a>
</li>
            
<li>
    <a href="../../Chap24/Problems/24-2/" class="dropdown-item">24-2 Nesting boxes</a>
</li>
            
<li>
    <a href="../../Chap24/Problems/24-3/" class="dropdown-item">24-3 Arbitrage</a>
</li>
            
<li>
    <a href="../../Chap24/Problems/24-4/" class="dropdown-item">24-4 Gabow's scaling algorithm for single-source shortest paths</a>
</li>
            
<li>
    <a href="../../Chap24/Problems/24-5/" class="dropdown-item">24-5 Karp's minimum mean-weight cycle algorithm</a>
</li>
            
<li>
    <a href="../../Chap24/Problems/24-6/" class="dropdown-item">24-6 Bitonic shortest paths</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">25 All-Pairs Shortest Paths</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap25/25.1/" class="dropdown-item">25.1 Shortest paths and matrix multiplication</a>
</li>
            
<li>
    <a href="../../Chap25/25.2/" class="dropdown-item">25.2 The Floyd-Warshall algorithm</a>
</li>
            
<li>
    <a href="../../Chap25/25.3/" class="dropdown-item">25.3 Johnson's algorithm for sparse graphs</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 25 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap25/Problems/25-1/" class="dropdown-item">25-1 Transitive closure of a dynamic graph</a>
</li>
            
<li>
    <a href="../../Chap25/Problems/25-2/" class="dropdown-item">25-2 Shortest paths in epsilon-dense graphs</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">26 Maximum Flow</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap26/26.1/" class="dropdown-item">26.1 Flow networks</a>
</li>
            
<li>
    <a href="../../Chap26/26.2/" class="dropdown-item">26.2 The Ford-Fulkerson method</a>
</li>
            
<li>
    <a href="../../Chap26/26.3/" class="dropdown-item">26.3 Maximum bipartite matching</a>
</li>
            
<li>
    <a href="../../Chap26/26.4/" class="dropdown-item">26.4 Push-relabel algorithms</a>
</li>
            
<li>
    <a href="../../Chap26/26.5/" class="dropdown-item">26.5 The relabel-to-front algorithm</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 26 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap26/Problems/26-1/" class="dropdown-item">26-1 Escape problem</a>
</li>
            
<li>
    <a href="../../Chap26/Problems/26-2/" class="dropdown-item">26-2 Minimum path cover</a>
</li>
            
<li>
    <a href="../../Chap26/Problems/26-3/" class="dropdown-item">26-3 Algorithmic consulting</a>
</li>
            
<li>
    <a href="../../Chap26/Problems/26-4/" class="dropdown-item">26-4 Updating maximum flow</a>
</li>
            
<li>
    <a href="../../Chap26/Problems/26-5/" class="dropdown-item">26-5 Maximum flow by scaling</a>
</li>
            
<li>
    <a href="../../Chap26/Problems/26-6/" class="dropdown-item">26-6 The Hopcroft-Karp bipartite matching algorithm</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">问题 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">27 Multithreaded Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap27/27.1/" class="dropdown-item">27.1 The basics of dynamic multithreading</a>
</li>
            
<li>
    <a href="../../Chap27/27.2/" class="dropdown-item">27.2 Multithreaded matrix multiplication</a>
</li>
            
<li>
    <a href="../../Chap27/27.3/" class="dropdown-item">27.3 Multithreaded merge sort</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 27 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap27/Problems/27-1/" class="dropdown-item">27-1 Implementing parallel loops using nested parallelism</a>
</li>
            
<li>
    <a href="../../Chap27/Problems/27-2/" class="dropdown-item">27-2 Saving temporary space in matrix multiplication</a>
</li>
            
<li>
    <a href="../../Chap27/Problems/27-3/" class="dropdown-item">27-3 Multithreaded matrix algorithms</a>
</li>
            
<li>
    <a href="../../Chap27/Problems/27-4/" class="dropdown-item">27-4 Multithreading reductions and prefix computations</a>
</li>
            
<li>
    <a href="../../Chap27/Problems/27-5/" class="dropdown-item">27-5 Multithreading a simple stencil calculation</a>
</li>
            
<li>
    <a href="../../Chap27/Problems/27-6/" class="dropdown-item">27-6 Randomized multithreaded algorithms</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">28 Matrix Operations</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap28/28.1/" class="dropdown-item">28.1 Solving systems of linear equations</a>
</li>
            
<li>
    <a href="../../Chap28/28.2/" class="dropdown-item">28.2 Inverting matrices</a>
</li>
            
<li>
    <a href="../../Chap28/28.3/" class="dropdown-item">28.3 Symmetric positive-definite matrices and least-squares approximation</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 28 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap28/Problems/28-1/" class="dropdown-item">28-1 Tridiagonal systems of linear equations</a>
</li>
            
<li>
    <a href="../../Chap28/Problems/28-2/" class="dropdown-item">28-2 Splines</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">29 Linear Programming</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap29/29.1/" class="dropdown-item">29.1 Standard and slack forms</a>
</li>
            
<li>
    <a href="../../Chap29/29.2/" class="dropdown-item">29.2 Formulating problems as linear programs</a>
</li>
            
<li>
    <a href="../../Chap29/29.3/" class="dropdown-item">29.3 The simplex algorithm</a>
</li>
            
<li>
    <a href="../../Chap29/29.4/" class="dropdown-item">29.4 Duality</a>
</li>
            
<li>
    <a href="../../Chap29/29.5/" class="dropdown-item">29.5 The initial basic feasible solution</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 29 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap29/Problems/29-1/" class="dropdown-item">29-1 Linear-inequality feasibility</a>
</li>
            
<li>
    <a href="../../Chap29/Problems/29-2/" class="dropdown-item">29-2 Complementary slackness</a>
</li>
            
<li>
    <a href="../../Chap29/Problems/29-3/" class="dropdown-item">29-3 Integer linear programming</a>
</li>
            
<li>
    <a href="../../Chap29/Problems/29-4/" class="dropdown-item">29-4 Farkas'ss lemma</a>
</li>
            
<li>
    <a href="../../Chap29/Problems/29-5/" class="dropdown-item">29-5 Minimum-cost circulation</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">30 Polynomials and the FFT</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap30/30.1/" class="dropdown-item">30.1 Representing polynomials</a>
</li>
            
<li>
    <a href="../../Chap30/30.2/" class="dropdown-item">30.2 The DFT and FFT</a>
</li>
            
<li>
    <a href="../../Chap30/30.3/" class="dropdown-item">30.3 Efficient FFT implementations</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 30 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap30/Problems/30-1/" class="dropdown-item">30-1 Divide-and-conquer multiplication</a>
</li>
            
<li>
    <a href="../../Chap30/Problems/30-2/" class="dropdown-item">30-2 Toeplitz matrices</a>
</li>
            
<li>
    <a href="../../Chap30/Problems/30-3/" class="dropdown-item">30-3 Multidimensional fast Fourier transform</a>
</li>
            
<li>
    <a href="../../Chap30/Problems/30-4/" class="dropdown-item">30-4 Evaluating all derivatives of a polynomial at a point</a>
</li>
            
<li>
    <a href="../../Chap30/Problems/30-5/" class="dropdown-item">30-5 Polynomial evaluation at multiple points</a>
</li>
            
<li>
    <a href="../../Chap30/Problems/30-6/" class="dropdown-item">30-6 FFT using modular arithmetic</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">31 Number-Theoretic Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap31/31.1/" class="dropdown-item">31.1 Elementary number-theoretic notions</a>
</li>
            
<li>
    <a href="../../Chap31/31.2/" class="dropdown-item">31.2 Greatest common divisor</a>
</li>
            
<li>
    <a href="../../Chap31/31.3/" class="dropdown-item">31.3 Modular arithmetic</a>
</li>
            
<li>
    <a href="../../Chap31/31.4/" class="dropdown-item">31.4 Solving modular linear equations</a>
</li>
            
<li>
    <a href="../../Chap31/31.5/" class="dropdown-item">31.5 The Chinese remainder theorem</a>
</li>
            
<li>
    <a href="../../Chap31/31.6/" class="dropdown-item">31.6 Powers of an element</a>
</li>
            
<li>
    <a href="../../Chap31/31.7/" class="dropdown-item">31.7 The RSA public-key cryptosystem</a>
</li>
            
<li>
    <a href="../../Chap31/31.8/" class="dropdown-item">31.8 Primality testing</a>
</li>
            
<li>
    <a href="../../Chap31/31.9/" class="dropdown-item">31.9 Integer factorization</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 31 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap31/Problems/31-1/" class="dropdown-item">31-1 Binary gcd algorithm</a>
</li>
            
<li>
    <a href="../../Chap31/Problems/31-2/" class="dropdown-item">31-2 Analysis of bit operations in Euclid's algorithm</a>
</li>
            
<li>
    <a href="../../Chap31/Problems/31-3/" class="dropdown-item">31-3 Three algorithms for Fibonacci numbers</a>
</li>
            
<li>
    <a href="../../Chap31/Problems/31-4/" class="dropdown-item">31-4 Quadratic residues</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">32 String Matching</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap32/32.1/" class="dropdown-item">32.1 The naive string-matching algorithm</a>
</li>
            
<li>
    <a href="../../Chap32/32.2/" class="dropdown-item">32.2 The Rabin-Karp algorithm</a>
</li>
            
<li>
    <a href="../../Chap32/32.3/" class="dropdown-item">32.3 String matching with finite automata</a>
</li>
            
<li>
    <a href="../../Chap32/32.4/" class="dropdown-item">32.4 The Knuth-Morris-Pratt algorithm</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 32 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap32/Problems/32-1/" class="dropdown-item">32-1 String matching based on repetition factors</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">33 Computational Geometry</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap33/33.1/" class="dropdown-item">33.1 Line-segment properties</a>
</li>
            
<li>
    <a href="../../Chap33/33.2/" class="dropdown-item">33.2 Determining whether any pair of segments intersects</a>
</li>
            
<li>
    <a href="../../Chap33/33.3/" class="dropdown-item">33.3 Finding the convex hull</a>
</li>
            
<li>
    <a href="../../Chap33/33.4/" class="dropdown-item">33.4 Finding the closest pair of points</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 33 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap33/Problems/33-1/" class="dropdown-item">33-1 Convex layers</a>
</li>
            
<li>
    <a href="../../Chap33/Problems/33-2/" class="dropdown-item">33-2 Maximal layers</a>
</li>
            
<li>
    <a href="../../Chap33/Problems/33-3/" class="dropdown-item">33-3 Ghostbusters and ghosts</a>
</li>
            
<li>
    <a href="../../Chap33/Problems/33-4/" class="dropdown-item">33-4 Picking up sticks</a>
</li>
            
<li>
    <a href="../../Chap33/Problems/33-5/" class="dropdown-item">33-5 Sparse-hulled distributions</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">34 NP-Completeness</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap34/34.1/" class="dropdown-item">34.1 Polynomial time</a>
</li>
            
<li>
    <a href="../../Chap34/34.2/" class="dropdown-item">34.2 Polynomial-time verification</a>
</li>
            
<li>
    <a href="../../Chap34/34.3/" class="dropdown-item">34.3 NP-completeness and reducibility</a>
</li>
            
<li>
    <a href="../../Chap34/34.4/" class="dropdown-item">34.4 NP-completeness proofs</a>
</li>
            
<li>
    <a href="../../Chap34/34.5/" class="dropdown-item">34.5 NP-complete problems</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 34 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap34/Problems/34-1/" class="dropdown-item">34-1 Independent set</a>
</li>
            
<li>
    <a href="../../Chap34/Problems/34-2/" class="dropdown-item">34-2 Bonnie and Clyde</a>
</li>
            
<li>
    <a href="../../Chap34/Problems/34-3/" class="dropdown-item">34-3 Graph coloring</a>
</li>
            
<li>
    <a href="../../Chap34/Problems/34-4/" class="dropdown-item">34-4 Scheduling with profits and deadlines</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">35 Approximation Algorithms</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap35/35.1/" class="dropdown-item">35.1 The vertex-cover problem</a>
</li>
            
<li>
    <a href="../../Chap35/35.2/" class="dropdown-item">35.2 The traveling-salesman problem</a>
</li>
            
<li>
    <a href="../../Chap35/35.3/" class="dropdown-item">35.3 The set-covering problem</a>
</li>
            
<li>
    <a href="../../Chap35/35.4/" class="dropdown-item">35.4 Randomization and linear programming</a>
</li>
            
<li>
    <a href="../../Chap35/35.5/" class="dropdown-item">35.5 The subset-sum problem</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Chap 35 Problems</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Chap35/Problems/35-1/" class="dropdown-item">35-1 Bin packing</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-2/" class="dropdown-item">35-2 Approximating the size of a maximum clique</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-3/" class="dropdown-item">35-3 Weighted set-covering problem</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-4/" class="dropdown-item">35-4 Maximum matching</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-5/" class="dropdown-item">35-5 Parallel machine scheduling</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-6/" class="dropdown-item">35-6 Approximating a maximum spanning tree</a>
</li>
            
<li>
    <a href="../../Chap35/Problems/35-7/" class="dropdown-item">35-7 An approximation algorithm for the 0-1 knapsack problem</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../22.2/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../22.4/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/cjql/algorithm/edit/master/docs/Chap22/22.3.md" class="nav-link">Edit on cjql/algorithm</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="2"><a href="#223-1" class="nav-link">22.3-1</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-2" class="nav-link">22.3-2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-3" class="nav-link">22.3-3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-4" class="nav-link">22.3-4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-5" class="nav-link">22.3-5</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-6" class="nav-link">22.3-6</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-7" class="nav-link">22.3-7</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-8" class="nav-link">22.3-8</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-9" class="nav-link">22.3-9</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-10" class="nav-link">22.3-10</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-11" class="nav-link">22.3-11</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-12" class="nav-link">22.3-12</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#223-13-star" class="nav-link">22.3-13 $\star$</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h2 id="223-1">22.3-1</h2>
<blockquote>
<p>Make a $3$-by-$3$ chart with row and column labels $\text{WHITE}$, $\text{GRAY}$, and $\text{BLACK}$. In each cell $(i, j)$, indicate whether, at any point during a depth-first search of a directed graph, there can be an edge from a vertex of color $i$ to a vertex of color $j$. For each possible edge, indicate what edge types it can be. Make a second such chart for depth-first search of an undirected graph.</p>
</blockquote>
<p>According to Theorem 22.7 (Parenthesis theorem), there are 3 cases of relationship between intervals of vertex $u$ and $v$:</p>
<ul>
<li>$[u.d, u.f]$ and $[v.d, v.f]$ are entirely disjointed,</li>
<li>$[u.d, u.f] \subset [v.d, v.f]$, and</li>
<li>$[v.d, v.f] \subset [u.d, u.f]$.</li>
</ul>
<p>We judge the possibility according to this Theorem.</p>
<ul>
<li>
<p>For <strong>directed graph</strong>, we can use the edge classification given by exercise 22.3-5 to simplify the problem.</p>
<p>$$
\begin{array}{c|ccc}
from \diagdown to &amp; \text{WHITE}         &amp; \text{GRAY}                &amp; \text{BLACK} \\
\hline
\text{WHITE}      &amp; \text{All kinds}     &amp; \text{Cross, Back}         &amp; \text{Cross} \\
\text{GRAY}       &amp; \text{Tree, Forward} &amp; \text{Tree, Forward, Back} &amp; \text{Tree, Forward, Cross} \\
\text{BLACK}      &amp; -                    &amp; \text{Back}                &amp; \text{All kinds}
\end{array}
$$</p>
</li>
<li>
<p>For <strong>undirected graph</strong>, starting from directed chart, we remove the forward edge and the cross edge, and </p>
<ul>
<li>when a back edge exist, we add a tree edge;</li>
<li>when a tree edge exist, we add a back edge.</li>
</ul>
<p>This is correct for the following reasons:</p>
<ol>
<li>Theorem 22.10: In a depth-first search of an undirected graph $G$, every edge of $G$ is either a tree or back edge. So tree and back edge only.</li>
<li>If $(u, v)$ is a tree edge from $u$'s perspective, $(u, v)$ is also a back edge from $v$'s perspective.</li>
</ol>
<p>$$
\begin{array}{c|ccc}
from \diagdown to &amp; \text{WHITE}      &amp; \text{GRAY}       &amp; \text{BLACK} \\
\hline
\text{WHITE}      &amp; -                 &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\
\text{GRAY}       &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; \text{Tree, Back} \\
\text{BLACK}      &amp; \text{Tree, Back} &amp; \text{Tree, Back} &amp; -
\end{array}
$$</p>
</li>
</ul>
<h2 id="223-2">22.3-2</h2>
<blockquote>
<p>Show how depth-first search works on the graph of Figure 22.6. Assume that the <strong>for</strong> loop of lines 5–7 of the $\text{DFS}$ procedure considers the vertices in alphabetical order, and assume that each adjacency list is ordered alphabetically. Show the discovery and finishing times for each vertex, and show the classification of each edge.</p>
</blockquote>
<p>The following table gives the discovery time and finish time for each vetex in the graph.</p>
<p>See the <a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3.cpp">C++ demo</a>.</p>
<p>$$
\begin{array}{ccc}
\text{Vertex} &amp; \text{Discovered} &amp; \text{Finished} \\
\hline
q &amp;  1 &amp; 16 \\
r &amp; 17 &amp; 20 \\
s &amp;  2 &amp;  7 \\
t &amp;  8 &amp; 15 \\
u &amp; 18 &amp; 19 \\
v &amp;  3 &amp;  6 \\
w &amp;  4 &amp;  5 \\
x &amp;  9 &amp; 12 \\
y &amp; 13 &amp; 14 \\
z &amp; 10 &amp; 11
\end{array}
$$</p>
<ul>
<li><strong>Tree edges:</strong> $(q, s)$, $(s, v)$, $(v, w)$, $(q, t)$, $(t, x)$, $(x, z)$, $(t, y)$, $(r, u)$.</li>
<li><strong>Back edges:</strong> $(w, s)$, $(z, x)$, $(y, q)$.</li>
<li><strong>Forward edges:</strong> $(q, w)$.</li>
<li><strong>Cross edges:</strong> $(r, y)$, $(u, y)$.</li>
</ul>
<h2 id="223-3">22.3-3</h2>
<blockquote>
<p>Show the parenthesis structure of the depth-first search of Figure 22.4.</p>
</blockquote>
<p>The parentheses structure of the depth-first search of Figure 22.4 is $(u(v(y(xx)y)v)u)(w(zz)w)$.</p>
<h2 id="223-4">22.3-4</h2>
<blockquote>
<p>Show that using a single bit to store each vertex color suffices by arguing that the $\text{DFS}$ procedure would produce the same result if line 3 of $\text{DFS-VISIT}$ was removed.</p>
</blockquote>
<p>Change line 3 to <code>color = BLACK</code> and remove line 8. Then, the algorithm would produce the same result.</p>
<h2 id="223-5">22.3-5</h2>
<blockquote>
<p>Show that edge $(u, v)$ is</p>
<p><strong>a.</strong> a tree edge or forward edge if and only if $u.d &lt; v.d &lt; v.f &lt; u.f$,</p>
<p><strong>b.</strong> a back edge if and only if $v.d \le u.d &lt; u.f \le v.f$, and</p>
<p><strong>c.</strong> a cross edge if and only if $v.d &lt; v.f &lt; u.d &lt; u.f$.</p>
</blockquote>
<p><strong>a.</strong> $u$ is an ancestore of $v$.</p>
<p><strong>b.</strong> $u$ is a descendant of $v$.</p>
<p><strong>c.</strong> $v$ is visited before $u$.</p>
<h2 id="223-6">22.3-6</h2>
<blockquote>
<p>Show that in an undirected graph, classifying an edge $(u, v)$ as a tree edge or a back edge according to whether $(u, v)$ or $(v, u)$ is encountered first during the depth-first search is equivalent to classifying it according to the ordering of the four types in the classification scheme.</p>
</blockquote>
<p>By Theorem 22.10, every edge of an undirected graph is either a tree edge or a back edge. First suppose that $v$ is first discovered by exploring edge $(u, v)$. Then by definition, $(u, v)$ is a tree edge. Moreover, $(u, v)$ must have been discovered before $(v, u)$ because once $(v, u)$ is explored, $v$ is necessarily discovered. Now suppose that $v$ isn't first discovered by $(u, v)$. Then it must be discovered by $(r, v)$ for some $r\ne u$. If $u$ hasn't yet been discovered then if $(u, v)$ is explored first, it must be a back edge since $v$ is an ancestor of $u$. If $u$ has been discovered then $u$ is an ancestor of $v$, so $(v, u)$ is a back edge.</p>
<h2 id="223-7">22.3-7</h2>
<blockquote>
<p>Rewrite the procedure $\text{DFS}$, using a stack to eliminate recursion.</p>
</blockquote>
<p>See the <a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-7/22.3-7.cpp">C++ demo</a>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="n">DFS</span><span class="o">-</span><span class="n">STACK</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">WHITE</span>
        <span class="n">u</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">S</span> <span class="o">=</span> <span class="err">Ø</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">while</span> <span class="o">!</span><span class="n">STACK</span><span class="o">-</span><span class="n">EMPTY</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">TOP</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
                <span class="n">isNeighborhoodsAllDiscovered</span> <span class="o">=</span> <span class="nb">true</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">GRAY</span>
                    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">w</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">w</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
                            <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">w</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
                            <span class="n">w</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
                            <span class="n">PUSH</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                            <span class="n">isNeighborhoodsAllDiscovered</span> <span class="o">=</span> <span class="nb">false</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="n">isNeighborhoodsAllDiscovered</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">v</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">time</span>
                    <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
                    <span class="n">POP</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>

<h2 id="223-8">22.3-8</h2>
<blockquote>
<p>Give a counterexample to the conjecture that if a directed graph $G$ contains a path from $u$ to $v$, and if $u.d &lt; v.d$ in a depth-first search of $G$, then $v$ is a descendant of $u$ in the depth-first forest produced.</p>
</blockquote>
<p>Consider a graph with $3$ vertices $u$, $v$, and $w$, and with edges $(w, u)$, $(u, w)$, and $(w, v)$. Suppose that $\text{DFS}$ first explores $w$, and that $w$'s adjacency list has $u$ before $v$. We next discover $u$. The only adjacent vertex is $w$, but $w$ is already grey, so $u$ finishes. Since $v$ is not yet a descendant of $u$ and $u$ is finished, $v$ can never be a descendant of $u$.</p>
<h2 id="223-9">22.3-9</h2>
<blockquote>
<p>Give a counterexample to the conjecture that if a directed graph $G$ contains a path from $u$ to $v$, then any depth-first search must result in $v.d \le u.f$.</p>
</blockquote>
<p>Consider the directed graph on the vertices $\{1, 2, 3\}$, and having the edges $(1, 2)$, $(1, 3)$, $(2, 1)$ then there is a path from $2$ to $3$. However, if we start a $\text{DFS}$ at $1$ and process $2$ before $3$, we will have $2.f = 3 &lt; 2 = 2.d$ which provides a counterexample to the given conjecture.</p>
<h2 id="223-10">22.3-10</h2>
<blockquote>
<p>Modify the pseudocode for depth-first search so that it prints out every edge in the directed graph $G$, together with its type. Show what modifications, if any, you need to make if $G$ is undirected.</p>
</blockquote>
<p>If $G$ is undirected we don't need to make any modifications.</p>
<p>See the <a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-10/22.3-10.cpp">C++ demo</a>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="o">-</span><span class="n">PRINT</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
            <span class="n">print</span> <span class="s">&quot;(u, v) is a tree edge.&quot;</span>
            <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="o">-</span><span class="n">PRINT</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">GRAY</span>
            <span class="n">print</span> <span class="s">&quot;(u, v) is a back edge.&quot;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">.</span><span class="n">d</span>
            <span class="n">print</span> <span class="s">&quot;(u, v) is a forward edge.&quot;</span>
        <span class="k">else</span> 
            <span class="n">print</span> <span class="s">&quot;(u, v) is a cross edge.&quot;</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">time</span>
</code></pre></div>
</td></tr></table>

<h2 id="223-11">22.3-11</h2>
<blockquote>
<p>Explain how a vertex $u$ of a directed graph can end up in a depth-first tree containing only $u$, even though $u$ has both incoming and outgoing edges in $G$.</p>
</blockquote>
<p>Suppose that we have a directed graph on the vertices $\{1, 2, 3\}$ and having edges $(1, 2)$ and $(2, 3)$. Then, $2$ has both incoming and outgoing edges.</p>
<p>If we pick our first root to be $3$, that will be in its own $\text{DFS}$ tree. Then, we pick our second root to be $2$, since the only thing it points to has already been marked $\text{BLACK}$, we won't be exploring it. Then, picking the last root to be $1$, we don't screw up the fact that $2$ is along in a $\text{DFS}$ tree even though it has both an incoming and outgoing edge in $G$.</p>
<h2 id="223-12">22.3-12</h2>
<blockquote>
<p>Show that we can use a depth-first search of an undirected graph $G$ to identify the connected components of $G$, and that the depth-first forest contains as many trees as $G$ has connected components. More precisely, show how to modify depth-first search so that it assigns to each vertex $v$ an integer label $v.cc$ between $1$ and $k$, where $k$ is the number of connected components of $G$, such that $u.cc = v.cc$ if and only if $u$ and $v$ are in the same connected component.</p>
</blockquote>
<p>The modifications work as follows: each time the <strong>if</strong>-condition of line 8 is satisfied in $\text{DFS-CC}$, we have a new root of a tree in the forest, so we update its $cc$ label to be a new value of $k$. In the recursive calls to $\text{DFS-VISIT-CC}$, we always update a descendant's connected component to agree with its ancestor's.</p>
<p>See the <a href="https://github.com/walkccc/CLRS-cpp/blob/master/Chap22/22.3-12/22.3-12.cpp">C++ demo</a>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="n">DFS</span><span class="o">-</span><span class="n">CC</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">WHITE</span>
        <span class="n">u</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">NIL</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
            <span class="n">u</span><span class="p">.</span><span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">cc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="o">-</span><span class="n">CC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="o">-</span><span class="n">CC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">time</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">GRAY</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="err">∈</span> <span class="n">G</span><span class="p">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">WHITE</span>
            <span class="n">v</span><span class="p">.</span><span class="n">cc</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">cc</span>
            <span class="n">v</span><span class="p">.</span><span class="err">π</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">DFS</span><span class="o">-</span><span class="n">VISIT</span><span class="o">-</span><span class="n">CC</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">u</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">u</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">time</span>
</code></pre></div>
</td></tr></table>

<h2 id="223-13-star">22.3-13 $\star$</h2>
<blockquote>
<p>A directed graph $G = (V, E)$ is <strong><em>singly connected</em></strong> if $u \leadsto v$ implies that $G$ contains at most one simple path from $u$ to $v$ for all vertices $u, v \in V$. Give an efficient algorithm to determine whether or not a directed graph is singly connected.</p>
</blockquote>
<p>This can be done in time $O(|V||E|)$. To do this, first perform a topological sort of the vertices. Then, we will contain for each vertex a list of it's ancestors with $in\text-degree$ $0$. We compute these lists for each vertex in the order starting from the earlier ones topologically.</p>
<p>Then, if we ever have a vertex that has the same degree $0$ vertex appearing in the lists of two of its immediate parents, we know that the graph is not singly connected. however, if at each step we have that at each step all of the parents have disjoint sets of degree $0$ vertices as ancestors, the graph is singly connected. Since, for each vertex, the amount of time required is bounded by the number of vertices times the $in\text-degree$ of the particular vertex, the total runtime is bounded by $O(|V||E|)$.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Built by <a href="http://github.com/cjql">cj</a> &copy; 2020 - </p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../js/katex.js" defer></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
